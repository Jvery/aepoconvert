# Progress Log

## Learnings
(Patterns discovered during implementation)
- Next.js 16.1.1 is installed when using `create-next-app@latest` (newer than the "14" mentioned in PRD, but compatible)
- Strict mode is already enabled by default in new Next.js projects
- Need to create project in temp location then copy files to avoid overwriting existing files (PRD.md, progress.txt)
- shadcn/ui: In newer versions, `--style` flag is removed; New York is the default style
- shadcn/ui: Use `--defaults --base-color zinc --yes` flags for non-interactive setup
- shadcn/ui: Tailwind v4 is automatically detected and configured
- shadcn/ui: `toast` component is deprecated, use `sonner` instead
- next-intl: Need to create src/i18n/routing.ts with defineRouting for middleware configuration
- next-intl: createNextIntlPlugin in next.config.ts takes path to request.ts file as argument
- Next.js 16: "middleware" file convention is deprecated, prefer "proxy" (but still works for now)
- @imagemagick/magick-wasm: Static `read()` is on `ImageMagick` class, not `MagickImage` class
- @imagemagick/magick-wasm: MagickFormat has constants for modern formats (Avif, Jxl, Heic, Heif) and RAW formats (Nef, Cr2, Cr3, Arw, etc.)
- @ffmpeg/ffmpeg: Use FFmpeg class with load() method; use toBlobURL from @ffmpeg/util for CORS-safe CDN loading
- @ffmpeg/ffmpeg: Multi-threading requires SharedArrayBuffer (check window.crossOriginIsolated)
- @ffmpeg/ffmpeg: readFile() returns Uint8Array with SharedArrayBuffer; use `new Uint8Array(data).buffer` for clean ArrayBuffer for Blob
- @ffmpeg/ffmpeg: ALAC encoding requires `-f ipod` container format flag in addition to `-c:a alac` codec
- pandoc-wasm: npm package bundles WASM binary; use Pandoc class with init() and run() methods; no manual download needed
- Zustand: Selectors returning objects cause infinite re-renders; use `useShallow` from 'zustand/react/shallow' for object selectors

## Iterations

### Iteration 1 - US-001: Initialize Next.js 14 project
**Status:** ✅ SUCCESS
**What was done:**
- Created Next.js project with TypeScript, Tailwind, ESLint, App Router, src-dir structure
- Verified tsconfig.json has strict mode enabled
- Verified `npm run dev` starts without errors
- Verified `npm run build` (typecheck) passes

---

### Iteration 34 - US-034: Create SettingsPanel combining simple and advanced
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/settings/SettingsPanel.tsx` with a collapsible container and expand/collapse button (hidden by default)
- Added shadcn Tabs for switching between Simple and Advanced quality controls, rendering existing SimpleQualitySettings and AdvancedQualitySettings components
- Synced tab selection with the conversion store mode for consistent state
- Integrated the SettingsPanel into `src/app/[locale]/page.tsx` in place of the previous side-by-side demo
- Verified typecheck passes with `npm run build`

**Learnings:**
- Use `overflow-hidden` with animated max-height transitions to fully hide collapsible content
- Syncing tab changes to shared state avoids mode mismatches when switching between preset and advanced controls

---

### Iteration 2 - US-002: Install and configure shadcn/ui
**Status:** ✅ SUCCESS
**What was done:**
- Ran `npx shadcn@latest init --defaults --base-color zinc --yes` (New York style is now the default)
- Verified components.json created with correct paths (style: "new-york", baseColor: "zinc")
- Installed Button component with `npx shadcn@latest add button`
- Updated page.tsx to render Button components (default and outline variants)
- Verified typecheck passes with `npm run build`
- Verified Button renders correctly in browser

**Learnings:**
- In newer shadcn versions, `--style` flag is removed; New York is the default style
- Use `--defaults --base-color zinc --yes` flags for non-interactive setup
- Tailwind v4 is now detected and used by shadcn

---

### Iteration 3 - US-003: Add essential shadcn components
**Status:** ✅ SUCCESS
**What was done:**
- Installed shadcn components: card, select, slider, progress, sonner, tabs, dialog, tooltip, badge, dropdown-menu
- Note: `toast` component is deprecated, used `sonner` as replacement
- Verified all components are importable from `@/components/ui/*`
- Verified typecheck passes with `npm run build`

**Learnings:**
- The `toast` shadcn component is deprecated and replaced by `sonner`
- Use `npx shadcn@latest add sonner` instead of `npx shadcn@latest add toast`

---

### Iteration 4 - US-004: Setup i18n architecture with next-intl
**Status:** ✅ SUCCESS
**What was done:**
- Installed `next-intl` package
- Created `messages/en.json` with common, upload, convert, settings sections
- Created `src/i18n/request.ts` with getRequestConfig for locale loading
- Created `src/i18n/routing.ts` with defineRouting configuration (locales: ['en'], defaultLocale: 'en')
- Created `src/middleware.ts` for locale routing using createMiddleware
- Updated `next.config.ts` with createNextIntlPlugin wrapper
- Wrapped app layout with NextIntlClientProvider using getLocale() and getMessages()
- Verified typecheck passes with `npm run build`

**Learnings:**
- next-intl requires both routing.ts and request.ts configuration files
- createNextIntlPlugin takes path to request.ts as argument
- NextIntlClientProvider requires async layout function with getLocale() and getMessages() from 'next-intl/server'
- Next.js 16.1.1 shows deprecation warning for "middleware" file convention, recommending "proxy" instead

---

### Iteration 5 - US-005: Define TypeScript types for file conversion
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/types/index.ts` with all required type definitions
- Defined `ConversionStatus` type: 'pending' | 'converting' | 'complete' | 'error'
- Defined `ConvertibleFile` interface with all required properties (id, file, name, size, from, to, status, progress, error, result)
- Defined `FormatInfo` interface with name, extensions, mimeTypes, category, canConvertTo
- Defined `QualitySettings` interface with mode, quality, bitrate?, sampleRate?
- Added `FormatCategory` type for better type safety
- Added `QualityMode` type for better type safety
- Verified typecheck passes with `npm run build`

**Learnings:**
- Added helper types (FormatCategory, QualityMode) to make the code more readable and maintainable
- All types documented with JSDoc comments for better IDE support

---

### Iteration 6 - US-006: Create format registry for images
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/formats/image-formats.ts` with IMAGE_FORMATS array
- Defined 40 image formats with FormatInfo for each:
  - Web formats: PNG, JPEG, WebP, GIF, BMP
  - Professional: TIFF, ICO, SVG, PSD
  - Modern: AVIF, JPEG XL, HEIC, HEIF
  - RAW camera: NEF, CR2, CR3, ARW, DNG, ORF, RAF, RW2, PEF, SRW, ERF, NRW, KDC, DCR, MRW, 3FR, X3F
  - Other: TGA, PCX, PPM, PGM, PBM, PAM, XBM, XPM, EXR, HDR
- Each format has correct extensions, mimeTypes, and canConvertTo arrays
- Verified typecheck passes with `npm run build`

**Learnings:**
- Created COMMON_OUTPUT_FORMATS constant to reduce duplication for read-only formats
- RAW camera formats and some others are read-only (can convert FROM but not TO)

---

### Iteration 7 - US-007: Create format registry for audio
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/formats/audio-formats.ts` with AUDIO_FORMATS array
- Defined 10 audio formats with FormatInfo for each:
  - Common: MP3, WAV, OGG Vorbis, FLAC, AAC, M4A, Opus
  - Microsoft: WMA (read-only for output)
  - Apple/Professional: AIFF, ALAC
- Each format has correct extensions, mimeTypes, and canConvertTo arrays
- WMA is treated as input-only format (can convert FROM but limited output support)
- Verified typecheck passes with `npm run build`

**Learnings:**
- Followed same pattern as image-formats.ts with COMMON_AUDIO_OUTPUT_FORMATS constant
- Some formats like WMA have licensing restrictions, so they're input-only

---

### Iteration 8 - US-008: Create format registry for documents
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/formats/document-formats.ts` with DOCUMENT_FORMATS array
- Defined 12 document formats with FormatInfo for each:
  - PDF (Portable Document Format) - with limited output options
  - Microsoft Word: DOCX, DOC
  - Plain text: Markdown (md), Plain Text (txt)
  - Web: HTML
  - E-book: EPUB
  - OpenDocument: ODT
  - Rich Text: RTF
  - Technical: LaTeX, reStructuredText (rst), AsciiDoc
- Each format has correct extensions, mimeTypes, and canConvertTo arrays
- PDF has limited conversion options (to txt, html, md only)
- Verified typecheck passes with `npm run build`

**Learnings:**
- PDF is primarily a read format with limited output capabilities in Pandoc
- Some formats like LaTeX have multiple common extensions (tex, latex)
- AsciiDoc uses multiple extensions: adoc, asciidoc, asc

---

### Iteration 9 - US-009: Create unified format utilities
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/formats/index.ts` with unified format utilities
- Exported `ALL_FORMATS` combining IMAGE_FORMATS, AUDIO_FORMATS, and DOCUMENT_FORMATS (62+ formats total)
- Implemented `detectFormat(file: File)` - detects format by extension first, then falls back to MIME type
- Implemented `getConvertibleFormats(from: FormatInfo)` - returns array of FormatInfo objects for valid output formats
- Implemented `getFormatByExtension(ext: string)` - finds format by extension (handles dot prefix and case)
- Implemented `getFormatsByCategory(category: string)` - filters formats by category ('image', 'audio', 'document')
- Re-exported individual format arrays for convenience
- Verified typecheck passes with `npm run build`

**Learnings:**
- Used type guard `filter((format): format is FormatInfo => format !== null)` to properly type-narrow filtered results
- Accepted both `FormatCategory` and `string` for category parameter for flexibility

---

### Iteration 10 - US-010: Create conversion store with Zustand
**Status:** ✅ SUCCESS
**What was done:**
- Installed `zustand` and `immer` packages
- Created `src/store/conversion-store.ts` with full state management
- Defined state shape: { files: ConvertibleFile[], isConverting: boolean, globalSettings: QualitySettings }
- Implemented all required actions:
  - `addFiles(files: File[])` - adds files with auto-generated IDs and detected format
  - `removeFile(id: string)` - removes file by ID
  - `updateFile(id: string, updates)` - partial update of file properties
  - `setOutputFormat(id: string, format)` - sets target format for a file
  - `setGlobalSettings(settings)` - updates global quality settings
  - `startConversion()` - marks pending files as converting
  - `clearAll()` - clears all files and resets state
- Used immer middleware for immutable state updates
- Verified typecheck passes with `npm run build`

**Learnings:**
- Zustand with immer: import from 'zustand/middleware/immer' for immer middleware
- Use `set((state) => { state.prop = value })` pattern with immer for mutations
- generateId() helper for unique file IDs using timestamp + random string

---

### Iteration 11 - US-011: Setup ImageMagick WASM loader
**Status:** ✅ SUCCESS
**What was done:**
- Installed `@imagemagick/magick-wasm` package (v0.0.37)
- Created `src/lib/converters/magick-loader.ts`
- Implemented `initializeMagick()` async function that loads WASM from jsDelivr CDN
- Exported `isMagickReady` boolean flag, updated after successful initialization
- Added proper error handling and logging with detailed error messages
- Added initialization deduplication to prevent multiple concurrent init calls
- Added helper functions: `checkMagickReady()` and `resetMagickState()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- @imagemagick/magick-wasm v0.0.37 exports `initializeImageMagick(wasmLocation)` that accepts URL, ByteArray, or WebAssembly.Module
- Use jsDelivr CDN (cdn.jsdelivr.net/npm/...) for reliable WASM binary delivery
- Need to track initialization state with multiple flags (isInitializing, isMagickReady, initPromise) to handle concurrent calls

---

### Iteration 12 - US-012: Create ImageMagick converter class
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/converters/image-converter.ts`
- Implemented `convertImage(file: File, toFormat: string, quality: number): Promise<Blob>` function
- Used ImageMagick.read() static method to read source bytes into an image
- Used image.write() method with target MagickFormat to write converted data
- Defined FORMAT_MAP to map lowercase extensions to MagickFormat constants (png, jpeg, jpg, webp, gif, bmp, tiff, tif)
- Defined MIME_TYPE_MAP for correct output blob MIME types
- Applied quality setting for lossy formats (jpeg, jpg, webp) via image.quality property
- Added helper functions: `isSupportedOutputFormat()`, `getSupportedOutputFormats()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- Static `read()` method is on `ImageMagick` class, not `MagickImage` class
- ImageMagick.read() uses a callback pattern where the callback receives the IMagickImage instance
- image.write(format, callback) returns data via callback, need to copy Uint8Array before it goes out of scope
- MagickFormat is an object with format constants (e.g., MagickFormat.Png, MagickFormat.Jpeg)

---

### Iteration 13 - US-013: Extend ImageConverter for advanced formats
**Status:** ✅ SUCCESS
**What was done:**
- Added ICO output support (MagickFormat.Ico, image/x-icon)
- Added AVIF output support (MagickFormat.Avif, image/avif)
- Added JXL (JPEG XL) output support (MagickFormat.Jxl, image/jxl)
- Added HEIC/HEIF input support (read-only) via INPUT_ONLY_FORMATS map
- Added RAW camera format input support: NEF, CR2, CR3, ARW, DNG, ORF, RAF, RW2, PEF, SRW
- Updated LOSSY_FORMATS to include avif and jxl for quality settings
- Added helper functions: `isSupportedInputFormat()`, `getInputOnlyFormats()`, `getAllSupportedInputFormats()`, `isHeicFormat()`, `isRawFormat()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- MagickFormat has constants for modern formats: Avif, Jxl, Heic, Heif
- MagickFormat has constants for RAW formats: Nef, Cr2, Cr3, Arw, Dng, Orf, Raf, Rw2, Pef, Srw
- Separated FORMAT_MAP (output formats) and INPUT_ONLY_FORMATS (read-only formats) for clearer architecture
- AVIF and JXL are lossy formats that benefit from quality settings

---

### Iteration 14 - US-014: Setup FFmpeg WASM for audio
**Status:** ✅ SUCCESS
**What was done:**
- Installed `@ffmpeg/ffmpeg` (v0.12.15) and `@ffmpeg/util` packages
- Created `src/lib/converters/ffmpeg-loader.ts`
- Implemented `initializeFFmpeg(): Promise<FFmpeg>` async function
- Loads FFmpeg core from jsDelivr CDN using toBlobURL for CORS-safe loading
- Exported `isFFmpegReady` boolean flag, updated after successful initialization
- Added `checkSharedArrayBufferSupport()` and `checkCrossOriginIsolation()` functions
- Warns user if SharedArrayBuffer is unavailable (requires COOP/COEP headers)
- Added helper functions: `getFFmpegInstance()`, `checkFFmpegReady()`, `terminateFFmpeg()`, `resetFFmpegState()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- @ffmpeg/ffmpeg v0.12.15 uses FFmpeg class with load() method accepting coreURL, wasmURL, workerURL
- Use @ffmpeg/util's toBlobURL() to convert CDN URLs to blob URLs (avoids CORS and MIME type issues)
- FFmpeg requires SharedArrayBuffer for multi-threading; check window.crossOriginIsolated for header presence
- Worker is optional and only used when SharedArrayBuffer is available

---

### Iteration 15 - US-015: Create Audio converter function
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/converters/audio-converter.ts`
- Implemented `convertAudio(file: File, toFormat: string, settings: QualitySettings): Promise<Blob>`
- Created FORMAT_CONFIG map with codec settings for MP3, WAV, OGG, FLAC, AAC, M4A
- Writes input file to FFmpeg virtual FS and reads output after conversion
- Builds FFmpeg command with `-c:a` for codec, `-b:a` for bitrate, `-ar` for sample rate
- Applies bitrate from settings or calculates from quality (1-100 maps to 64-320 kbps)
- Cleans up temporary files in virtual filesystem after conversion
- Added helper functions: `isSupportedAudioOutputFormat()`, `getSupportedAudioOutputFormats()`, `getAudioMimeType()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- FFmpeg.readFile() returns Uint8Array which may have SharedArrayBuffer backing; use `new Uint8Array(data).buffer` to get clean ArrayBuffer for Blob creation
- FFmpeg virtual FS needs explicit writeFile() before exec() and readFile() after
- Always clean up virtual FS files in finally block to prevent memory leaks

---

### Iteration 16 - US-016: Extend AudioConverter for all formats
**Status:** ✅ SUCCESS
**What was done:**
- Added OPUS output support using libopus codec (extension: opus, mimeType: audio/opus)
- Added WMA output support using wmav2 codec (extension: wma, mimeType: audio/x-ms-wma)
- Added AIFF output support using pcm_s16be codec (extensions: aiff/aif, mimeType: audio/aiff)
- Added ALAC output support using alac codec in m4a container (extension: m4a with ipod container, mimeType: audio/mp4)
- Updated BITRATE_SUPPORTED_FORMATS to include opus and wma
- Added container format support in buildFFmpegArgs for ALAC (uses -f ipod flag)
- Sample rate (-ar) was already implemented in US-015
- Verified typecheck passes with `npm run build`

**Learnings:**
- ALAC (Apple Lossless Audio Codec) requires m4a container specified via `-f ipod` in FFmpeg
- WMA and OPUS both support bitrate settings like MP3/AAC/OGG
- AIFF uses pcm_s16be (16-bit signed big-endian PCM) codec, similar to WAV but with different byte order

---

### Iteration 17 - US-017: Setup Pandoc WASM for documents
**Status:** ✅ SUCCESS
**What was done:**
- Installed `pandoc-wasm` npm package (v0.0.2) which bundles Pandoc compiled for WebAssembly
- Created `src/lib/converters/pandoc-loader.ts` following the same pattern as magick-loader.ts and ffmpeg-loader.ts
- Implemented `initializePandoc(): Promise<void>` async function that initializes the Pandoc WASM binary
- Exported `isPandocReady` boolean flag, updated after successful initialization
- Added helper functions: `getPandocInstance()`, `checkPandocReady()`, `resetPandocState()`
- Added version logging during initialization for debugging
- Verified typecheck passes with `npm run build`

**Learnings:**
- pandoc-wasm npm package bundles the WASM binary internally and loads it via init() method
- No manual wasm download needed - the package handles fetching from its bundled gzipped wasm files
- Pandoc class provides: init(), run(params), getVersion() methods
- run() accepts { text, options: { from, to }, files?, citeproc? } parameters

---

### Iteration 18 - US-018: Create Document converter function
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/converters/document-converter.ts` with full document conversion functionality
- Implemented `convertDocument(file: File, toFormat: string): Promise<Blob>` function
- Created INPUT_FORMAT_MAP and OUTPUT_FORMAT_MAP for Pandoc format name mapping
- Supports text-based conversions: MD → HTML/DOCX/TXT, HTML → MD/TXT, TXT → MD/HTML, etc.
- Added MIME_TYPES map for correct output blob MIME types
- Added helper functions: `isSupportedDocumentInputFormat()`, `isSupportedDocumentOutputFormat()`, `getSupportedDocumentInputFormats()`, `getSupportedDocumentOutputFormats()`, `getDocumentMimeType()`
- Note: PDF output is not supported in browser (requires LaTeX engine)
- Verified typecheck passes with `npm run build`

**Learnings:**
- Pandoc WASM cannot generate PDF directly (requires LaTeX engine or wkhtmltopdf)
- Pandoc run() returns string for text-based output formats
- Input format is auto-detected from file extension using detectInputFormat() helper
- Pandoc format names differ from file extensions (e.g., 'plain' for txt, 'markdown' for md)

---

### Iteration 19 - US-019: Extend DocumentConverter for all formats
**Status:** ✅ SUCCESS
**What was done:**
- Added EPUB output support with base64 decoding for binary format
- Added ODT output support with base64 decoding for binary format
- Added RTF output support (text format)
- Added LaTeX output support (tex/latex extensions)
- Added RST (reStructuredText) support for both input and output
- Added AsciiDoc support for both input and output (adoc/asciidoc/asc extensions)
- Added `BINARY_OUTPUT_FORMATS` set to identify formats that return base64-encoded strings
- Added `isBinaryOutputFormat()` helper function
- Added `base64ToArrayBuffer()` helper function for decoding base64 to ArrayBuffer (avoiding SharedArrayBuffer type issues)
- Updated `convertDocument()` to handle binary output formats differently from text formats
- Verified typecheck passes with `npm run build`

**Learnings:**
- Pandoc WASM returns binary formats (DOCX, EPUB, ODT) as base64-encoded strings
- Text formats (RTF, LaTeX, RST, AsciiDoc) are returned as plain strings
- TypeScript strict mode requires using `new ArrayBuffer()` explicitly rather than getting buffer from Uint8Array to avoid SharedArrayBuffer type incompatibility with BlobPart
- Create a new ArrayBuffer explicitly and copy bytes into it for Blob compatibility

---

### Iteration 20 - US-020: Create unified Converter facade
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/converters/index.ts` as the unified entry point for all conversions
- Implemented `convert(file: ConvertibleFile, onProgress?, settings?): Promise<Blob>` function
- Created `detectCategory()` helper function that determines category from file format or MIME type
- Routing logic for image → convertImage, audio → convertAudio, document → convertDocument
- Progress callback called at 0%, 10%, and 100% during conversion
- Added `getConverterStatus()` function to check which converters are ready
- Added `initializeAllConverters()` function for preloading all WASM libraries at startup
- Re-exported individual converters and loaders for direct access when needed
- Verified typecheck passes with `npm run build`

**Learnings:**
- Using `detectFormat()` from formats utility provides category information from FormatInfo
- Fallback to MIME type prefix (image/, audio/, text/) when format detection fails
- Document converter doesn't need quality settings, but image and audio do
- Re-exports allow consumers to import from a single module while maintaining access to internals

---

### Iteration 21 - US-021: Create Web Worker for conversions
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/workers/conversion-worker.ts` for running conversions in a separate thread
- Worker receives messages: `{ type: 'convert', file: File, from: string, to: string, settings: QualitySettings }`
- Worker posts progress updates: `{ type: 'progress', progress: number }`
- Worker posts completion: `{ type: 'complete', blob: Blob }` or `{ type: 'error', error: string }`
- Created `src/lib/converters/worker-client.ts` with `runConversion()` function that wraps Worker communication
- Added `isWorkerSupported()` helper to check Web Worker availability
- Added `convertWithWorkerFallback()` for graceful degradation when workers aren't available
- Verified typecheck passes with `npm run build`

**Learnings:**
- Web Workers use `new Worker(new URL('@/workers/...', import.meta.url), { type: 'module' })` pattern for ES module workers in Next.js
- Type definitions should be exported at declaration (not re-exported at end) to avoid duplicate export errors
- Worker client should terminate workers after completion to free resources
- Fallback to main thread conversion provides graceful degradation for environments without Worker support

---

### Iteration 22 - US-022: Create color theme and CSS variables
**Status:** ✅ SUCCESS
**What was done:**
- Updated `src/app/globals.css` with gradient CSS variables
- Added light mode variables: --gradient-start (purple), --gradient-end (magenta), --gradient-accent (cyan)
- Added dark mode variables with more vibrant colors for better contrast on dark backgrounds
- Created gradient utility classes:
  - `.gradient-bg` - static gradient background
  - `.gradient-bg-animated` - animated shifting gradient background
  - `.gradient-text` - gradient text effect using background-clip
  - `.gradient-text-animated` - animated gradient text effect
  - `.gradient-border` - gradient border using pseudo-element technique
  - `.gradient-border-animated` - animated gradient border
- Added `@keyframes gradient-shift` animation (8s ease infinite)
- Added `@keyframes gradient-rotate` for future use
- Included `prefers-reduced-motion: reduce` support for accessibility
- Verified typecheck passes with `npm run build`

**Learnings:**
- Use oklch color space for consistent, perceptually uniform gradient colors
- Gradient border technique uses pseudo-element with mask to create border effect
- Animation should use background-size: 300% with shifting position for smooth loops
- Always include prefers-reduced-motion media query for accessibility

---

### Iteration 23 - US-023: Create app layout with Header
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/layout/Header.tsx` with client-side theme management
- Displayed "aepoconvert" logo with gradient-text class (purple/pink gradient)
- Added theme toggle button with Sun/Moon icons from lucide-react
- lucide-react was already installed (no additional install needed)
- Header is sticky (top-0, z-50) with backdrop-blur-md effect
- Updated `src/app/layout.tsx` to import and include Header component
- Added `<main>` wrapper with min-height calculation for content area
- Verified typecheck passes with `npm run build`
- Verified visually in browser: light mode, dark mode toggle, and sticky behavior all working

**Learnings:**
- Theme toggle pattern: use useState for isDark, update document.documentElement.classList and localStorage
- Use mounted state to prevent hydration mismatch when checking initial theme
- Check both localStorage and system preference (prefers-color-scheme) for initial theme
- backdrop-blur works well with bg-background/80 for semi-transparent sticky header

---

### Iteration 24 - US-024: Create DropZone component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/upload/DropZone.tsx` with drag-and-drop functionality
- Large rectangular drop area with min-height: 200px
- Dashed border (border-dashed) with rounded corners (rounded-xl)
- Upload icon from lucide-react in circular background
- "Drop files here or click to browse" text with subtitle
- Hidden file input with multiple attribute for multi-file selection
- onDrop, onClick, onDragOver handlers with proper event handling
- Added accessibility: role="button", tabIndex, aria-label, keyboard navigation (Enter/Space)
- Fixed i18n routing: created [locale] folder structure with layout.tsx and page.tsx
- Updated root layout to delegate to locale layout
- Verified typecheck passes with `npm run build`
- Verified visually in browser: drop zone renders correctly with all elements

**Learnings:**
- next-intl middleware redirects `/` to `/en` but requires `[locale]` folder structure
- Root layout should return `children` directly when using locale-based layouts
- For accessibility, DropZone should have role="button", tabIndex, aria-label, and keyboard handlers
- Reset file input value after selection to allow re-selecting same file

---

### Iteration 25 - US-025: Add drag-over visual feedback to DropZone
**Status:** ✅ SUCCESS
**What was done:**
- Added `isDragging` state using useState hook to track drag state
- Added `dragCounter` ref to properly handle nested drag events (prevents flicker)
- Implemented `handleDragEnter` handler that increments counter and sets isDragging=true
- Implemented `handleDragLeave` handler that decrements counter and sets isDragging=false when counter reaches 0
- Updated `handleDrop` to reset dragCounter and isDragging state
- Added visual feedback when isDragging:
  - Border changes to accent color: `border-primary`
  - Background lightens: `bg-primary/10`
  - Subtle scale transform: `scale-[1.02]`
- Changed transition to `transition-all` for smooth animation of all properties
- Verified typecheck passes with `npm run build`
- Verified component renders correctly in browser

**Learnings:**
- Use dragCounter ref pattern to handle nested drag events - dragEnter fires for each child element
- Only set isDragging=true when counter becomes 1, set to false when counter returns to 0
- Reset counter to 0 in handleDrop to ensure clean state after drop
- transition-all with duration-200 and ease-out provides smooth visual feedback

---

### Iteration 26 - US-026: Add file type validation to DropZone
**Status:** ✅ SUCCESS
**What was done:**
- Added file filtering by supported extensions using `detectFormat()` from formats utility
- Imported `toast` from sonner for error notifications
- Implemented logic to separate supported and unsupported files
- Show descriptive toast.error() for unsupported files with file names
- Configured Toaster component in `src/app/[locale]/layout.tsx`
- Added `getAcceptedExtensions()` helper to display first 15 extensions + count of remaining
- Added `getAcceptAttribute()` helper to generate accept attribute for file input
- Added hint text showing accepted file types below the drop zone subtitle
- Added `accept` attribute to file input for browser-level filtering
- Verified typecheck passes with `npm run build`
- Verified component renders correctly in browser with Playwright

**Learnings:**
- sonner toast is already configured as shadcn/ui component (replaces deprecated toast)
- Use `toast.error(title, { description })` pattern for rich error messages
- Generate accept attribute from ALL_FORMATS to dynamically support all registered formats
- Show first 15 extensions in hint text to keep it readable, with "+ more" count for remaining

---

### Iteration 27 - US-027: Create FileCard component
**Status:** SUCCESS
**What was done:**
- Created `src/components/files/FileCard.tsx` component
- Props: file: ConvertibleFile, onRemove: () => void, onFormatChange: (format: string) => void
- Display file type icon based on category using lucide-react (FileImage, FileAudio, FileText, File)
- Show truncated file name preserving extension (truncateFileName helper)
- Format file size as human-readable KB/MB/GB (formatFileSize helper)
- Display detected format as Badge with category-based variant (default/secondary/outline)
- Remove button (X icon) in top-right corner with hover effects (opacity + destructive color)
- Uses shadcn Card component with subtle shadow and hover:shadow-md transition
- Verified typecheck passes with `npm run build`
- Verified component renders correctly in browser with Playwright screenshot

**Learnings:**
- Use lucide-react icons: FileImage, FileAudio, FileText for category-based file icons
- truncateFileName should preserve file extension when truncating long names
- formatFileSize: use Math.log to calculate appropriate unit (B, KB, MB, GB, TB)
- Badge variant can vary by category for visual distinction between file types

---

### Iteration 28 - US-028: Create FormatSelector component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/files/FormatSelector.tsx` component
- Props: currentFormat: string, availableFormats: FormatInfo[], onSelect: (format: string) => void
- Used shadcn Select component (SelectTrigger, SelectContent, SelectGroup, SelectItem, SelectLabel)
- Groups formats by category (image, audio, document) using SelectGroup with SelectLabel
- Shows format extension (uppercase) and format name in each SelectItem
- Added aria-label for accessibility
- Verified typecheck passes with `npm run build`
- Verified component renders and works correctly in browser with Playwright

**Learnings:**
- Use `reduce<Record<FormatCategory, FormatInfo[]>>` to group formats by category
- Filter out empty categories before rendering to avoid empty groups
- SelectLabel provides category headers within SelectGroup
- SelectValue can have custom content for displaying selected format

---

### Iteration 29 - US-029: Create ConversionProgress component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/files/ConversionProgress.tsx` component
- Props: status: ConversionStatus, progress: number, error: string | null
- Implemented four visual states:
  - Pending: Gray dot with "Waiting to convert" text
  - Converting: Spinner icon, percentage text, animated gradient progress bar with shimmer effect
  - Complete: Green checkmark in circle with "Complete" text
  - Error: Red alert icon with "Error" text and error message below
- Added `@keyframes shimmer` animation to globals.css for progress bar shimmer effect
- Used lucide-react icons: Loader2 (spinner), Check (checkmark), AlertCircle (error)
- Applied gradient-bg-animated class to progress bar fill
- Verified typecheck passes with `npm run build`
- Verified all four states render correctly in browser with Playwright screenshot

**Learnings:**
- Custom progress bar with gradient animation uses gradient-bg-animated class on inner div
- Shimmer effect overlay uses absolute positioning with translateX animation
- Use consistent sizing for status icons (h-5 w-5 container, h-3 w-3 icon)
- line-clamp-2 utility truncates error messages that are too long

---

### Iteration 30 - US-030: Create FileList component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/files/FileList.tsx` component
- Reads files from conversion store using useConversionStore hook
- Renders FileCard for each file with responsive CSS grid layout
- Grid: 1 column on mobile, 2 columns on sm (640px+), 3 columns on lg (1024px+)
- Empty state: shows FileX icon with "No files added yet" message and helpful subtitle
- Updated page.tsx to include FileList component
- Wired DropZone onFilesSelected to store's addFiles action
- Verified typecheck passes with `npm run build`
- Verified component works in browser: file upload displays FileCard, remove returns to empty state

**Learnings:**
- FileX icon from lucide-react works well for empty state visual
- Responsive grid uses `grid-cols-1 sm:grid-cols-2 lg:grid-cols-3` for progressive columns
- Early wiring of DropZone to store (via page.tsx) helps verify FileList functionality

---

### Iteration 31 - US-031: Add animations to FileList
**Status:** ✅ SUCCESS
**What was done:**
- Installed `framer-motion` package
- Imported motion and AnimatePresence from framer-motion
- Wrapped FileCard in motion.div with layout animation enabled
- Added enter animation: fade in (opacity 0→1) + slide up (y 20→0)
- Added exit animation: fade out (opacity 1→0) + slide up (y 0→-20)
- Used AnimatePresence with mode="popLayout" for proper exit animations
- Added fade-in animation to empty state for smoother transitions
- Verified typecheck passes with `npm run build`
- Verified animations work in browser: file entry, file removal, and empty state transitions all animated

**Learnings:**
- framer-motion's AnimatePresence requires mode="popLayout" or mode="wait" for exit animations in grid layouts
- motion.div with layout prop enables smooth grid rearrangement when items are added/removed
- Use easeOut timing function for natural-feeling animations (0.3s duration)
- Empty state can also benefit from a simple fade-in animation for polish

---

### Iteration 32 - US-032: Create SimpleQualitySettings component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/settings/SimpleQualitySettings.tsx` component
- Defined QUALITY_PRESETS constant with three options: Low (60%), Medium (80%), High (95%)
- Each preset has a label, value, and description
- Three Button components in a row using flex layout with gap-2
- Visual selection indicator: default variant (filled) when selected, outline variant when not
- Added ring-2 ring-primary/20 for extra visual feedback on selected button
- aria-pressed attribute for accessibility
- Updates global settings in store via setGlobalSettings({ quality, mode: 'simple' })
- Description updates dynamically based on selected preset
- Verified typecheck passes with `npm run build`
- Verified all three buttons work correctly in browser with selection state and description updates

**Learnings:**
- Use `variant={isSelected ? "default" : "outline"}` pattern for toggle button groups
- aria-pressed attribute communicates selection state to screen readers
- Show description for currently selected option rather than all at once for cleaner UI
- Use flex-1 on buttons to make them equal width in the row

---

### Iteration 33 - US-033: Create AdvancedQualitySettings component
**Status:** ✅ SUCCESS
**What was done:**
- Enhanced `AdvancedQualitySettings` with current value labels for quality, bitrate, and sample rate
- Added accessibility labels for the selects and kept store updates in advanced mode on every change
- Verified typecheck passes via `npm run build` (network access needed for next/font Google Fonts fetch)

**Learnings:**
- next/font build requires network access to download Google Fonts; rerun build with network permissions when restricted
- Showing current numeric values beside controls clarifies advanced settings state at a glance

---

### Iteration 35 - US-035: Create ConvertButton component
**Status:** ✅ SUCCESS
**What was done:**
- Added `src/components/actions/ConvertButton.tsx` with a large gradient primary action button
- Shows file count badge when files are present and disables when no files or a conversion is already running
- Displays a Loader2 spinner during conversion and triggers `startConversion()` on click
- Includes optional className prop for flexible placement in future action rows
- Verified typecheck passes with `npm run build`

**Learnings:**
- The `gradient-bg-animated` utility pairs well with the shadcn Button focus/spacing defaults to create a standout primary action
- Centralizing enable/disable state from the store (files length, isConverting) keeps button behavior aligned with global conversion status

---

### Iteration 36 - US-036: Create DownloadButton component
**Status:** ✅ SUCCESS
**What was done:**
- Installed `jszip` and added `src/components/actions/DownloadButton.tsx` that renders only when completed files exist
- Single-file downloads use the original filename with the new extension; multi-file downloads are packed into `aepoconvert-files.zip` with unique names
- Added animated checkmark badge, ZIP/download sublabel, and disabled loading state while generating archives
- Verified typecheck passes with `npm run build`

**Learnings:**
- JSZip accepts Blob objects directly, making it straightforward to stream converted results into an archive
- Building filenames with a Set prevents duplicate names when batching downloads
- Releasing object URLs shortly after triggering the anchor click avoids memory leaks in repeated downloads

---

### Iteration 37 - US-037: Create ClearAllButton component
**Status:** ✅ SUCCESS
**What was done:**
- Added `src/components/actions/ClearAllButton.tsx` with a ghost/outline aesthetic, dashed border, and accent hover glow
- Implemented a confirmation dialog (shadcn Dialog) with destructive/cancel actions before clearing all files
- Wired the confirm action to the store’s `clearAll()` and hide the button when no files are present
- Verified typecheck passes with `npm run build`

**Learnings:**
- Wrapping the trigger Button with Dialog provides a clean confirmation flow without extra state plumbing
- Light dashed outlines plus subtle glow give destructive actions emphasis while keeping them secondary to primary CTAs

---

### Iteration 38 - US-038: Assemble main page layout
**Status:** ✅ SUCCESS
**What was done:**
- Rebuilt `src/app/[locale]/page.tsx` into layered sections with gradient glows and glassy panels for clearer hierarchy
- Ordered the page as DropZone → FileList → SettingsPanel → action row inside a centered max-w-4xl container with mobile/desktop spacing (gap-4, sm:gap-6)
- Added action row with ConvertButton, DownloadButton (wired to store files), and ClearAllButton in a responsive flex layout
- Verified typecheck via `npm run build`

**Learnings:**
- Using light gradient orbs plus subtle borders/backdrop blur keeps focus on core components without redesigning them
- Combining gap utilities (gap-4 with sm:gap-6) cleanly satisfies mobile vs desktop spacing requirements in one stack

---

### Iteration 39 - US-039: Wire up file upload to store
**Status:** ✅ SUCCESS
**What was done:**
- DropZone now dispatches the conversion store’s `addFiles()` action directly for both drag-and-drop and file input selection, removing the need for parent wiring
- The conversion store now auto-detects each file’s format via `detectFormat()` and stores a canonical extension for the `from` field before queuing files
- Confirmed files appear immediately in FileList and typecheck passes with `npm run build`

**Learnings:**
- Using `detectFormat()` to choose between the canonical extension and the original filename extension keeps format metadata consistent across future format lookups
- Having DropZone call the store directly avoids missed callbacks and guarantees uploads surface in the UI as soon as they’re added

---

### Iteration 40 - US-040: Wire up format selection to store
**Status:** ✅ SUCCESS
**What was done:**
- Conversion store now assigns a default output format when adding files by choosing the first compatible extension (preferring one different from the source)
- FileList passes each file’s convertible formats into FileCard, which now surfaces a FormatSelector tied to the stored `file.to` value
- FormatSelector handles missing outputs gracefully and TypeScript checks pass with `npm run build`

**Learnings:**
- Preferring a convertible format that differs from the source avoids no-op defaults while still falling back when only one option exists
- Keeping the selector inside each FileCard makes the selected output format visible alongside other file metadata

---

### Iteration 41 - US-041: Wire up conversion to workers
**Status:** ✅ SUCCESS
**What was done:**
- startConversion now guards against concurrent runs, marks pending files as converting, and snapshots quality settings for consistent runs
- Each pending file is sent through convertWithWorkerFallback, updating per-file progress from worker messages
- Successful conversions store the resulting blob and mark status complete; failures record an error state without breaking other conversions
- isConverting resets once all conversions settle to re-enable the Convert button

**Learnings:**
- Taking a settings snapshot per run prevents mid-conversion UI tweaks from desynchronizing worker parameters
- Promise.allSettled ensures the converting flag clears even when some files fail
- Progress callbacks should ignore removed/non-converting files to avoid stale state writes

---

### Iteration 42 - US-042: Wire up download functionality
**Status:** ✅ SUCCESS
**What was done:**
- Verified DownloadButton already implemented triggerDownload() with object URL creation and anchor click download
- Verified buildFilename() uses original name with new extension from file.to
- Verified downloadZip() uses JSZip to create archive named "aepoconvert-files.zip"
- Verified object URLs are revoked after 2 seconds via setTimeout
- Fixed infinite loop bug in ConvertButton and ClearAllButton caused by Zustand selector returning new object on each render
- Added `useShallow` from 'zustand/react/shallow' to prevent unnecessary re-renders
- Typecheck passes and app works correctly in browser

**Learnings:**
- Zustand selectors that return objects `(state) => ({ a: state.a, b: state.b })` cause infinite re-renders because a new object is created each time
- Use `useShallow` wrapper from 'zustand/react/shallow' for object selectors to enable shallow comparison
- Alternative: select individual values with separate useConversionStore calls for each value

---
