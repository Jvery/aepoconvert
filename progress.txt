# Progress Log

## Learnings
(Patterns discovered during implementation)
- Next.js 16.1.1 is installed when using `create-next-app@latest` (newer than the "14" mentioned in PRD, but compatible)
- Strict mode is already enabled by default in new Next.js projects
- Need to create project in temp location then copy files to avoid overwriting existing files (PRD.md, progress.txt)
- shadcn/ui: In newer versions, `--style` flag is removed; New York is the default style
- shadcn/ui: Use `--defaults --base-color zinc --yes` flags for non-interactive setup
- shadcn/ui: Tailwind v4 is automatically detected and configured
- shadcn/ui: `toast` component is deprecated, use `sonner` instead
- next-intl: Need to create src/i18n/routing.ts with defineRouting for middleware configuration
- next-intl: createNextIntlPlugin in next.config.ts takes path to request.ts file as argument
- Next.js 16: "middleware" file convention is deprecated, prefer "proxy" (but still works for now)
- @imagemagick/magick-wasm: Static `read()` is on `ImageMagick` class, not `MagickImage` class
- @imagemagick/magick-wasm: MagickFormat has constants for modern formats (Avif, Jxl, Heic, Heif) and RAW formats (Nef, Cr2, Cr3, Arw, etc.)
- @ffmpeg/ffmpeg: Use FFmpeg class with load() method; use toBlobURL from @ffmpeg/util for CORS-safe CDN loading
- @ffmpeg/ffmpeg: Multi-threading requires SharedArrayBuffer (check window.crossOriginIsolated)
- @ffmpeg/ffmpeg: readFile() returns Uint8Array with SharedArrayBuffer; use `new Uint8Array(data).buffer` for clean ArrayBuffer for Blob
- @ffmpeg/ffmpeg: ALAC encoding requires `-f ipod` container format flag in addition to `-c:a alac` codec
- pandoc-wasm: npm package bundles WASM binary; use Pandoc class with init() and run() methods; no manual download needed
- Zustand: Selectors returning objects cause infinite re-renders; use `useShallow` from 'zustand/react/shallow' for object selectors

## Iterations

### Iteration 1 - US-001: Initialize Next.js 14 project
**Status:** ✅ SUCCESS
**What was done:**
- Created Next.js project with TypeScript, Tailwind, ESLint, App Router, src-dir structure
- Verified tsconfig.json has strict mode enabled
- Verified `npm run dev` starts without errors
- Verified `npm run build` (typecheck) passes

---

### Iteration 34 - US-034: Create SettingsPanel combining simple and advanced
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/settings/SettingsPanel.tsx` with a collapsible container and expand/collapse button (hidden by default)
- Added shadcn Tabs for switching between Simple and Advanced quality controls, rendering existing SimpleQualitySettings and AdvancedQualitySettings components
- Synced tab selection with the conversion store mode for consistent state
- Integrated the SettingsPanel into `src/app/[locale]/page.tsx` in place of the previous side-by-side demo
- Verified typecheck passes with `npm run build`

**Learnings:**
- Use `overflow-hidden` with animated max-height transitions to fully hide collapsible content
- Syncing tab changes to shared state avoids mode mismatches when switching between preset and advanced controls

---

### Iteration 2 - US-002: Install and configure shadcn/ui
**Status:** ✅ SUCCESS
**What was done:**
- Ran `npx shadcn@latest init --defaults --base-color zinc --yes` (New York style is now the default)
- Verified components.json created with correct paths (style: "new-york", baseColor: "zinc")
- Installed Button component with `npx shadcn@latest add button`
- Updated page.tsx to render Button components (default and outline variants)
- Verified typecheck passes with `npm run build`
- Verified Button renders correctly in browser

**Learnings:**
- In newer shadcn versions, `--style` flag is removed; New York is the default style
- Use `--defaults --base-color zinc --yes` flags for non-interactive setup
- Tailwind v4 is now detected and used by shadcn

---

### Iteration 3 - US-003: Add essential shadcn components
**Status:** ✅ SUCCESS
**What was done:**
- Installed shadcn components: card, select, slider, progress, sonner, tabs, dialog, tooltip, badge, dropdown-menu
- Note: `toast` component is deprecated, used `sonner` as replacement
- Verified all components are importable from `@/components/ui/*`
- Verified typecheck passes with `npm run build`

**Learnings:**
- The `toast` shadcn component is deprecated and replaced by `sonner`
- Use `npx shadcn@latest add sonner` instead of `npx shadcn@latest add toast`

---

### Iteration 4 - US-004: Setup i18n architecture with next-intl
**Status:** ✅ SUCCESS
**What was done:**
- Installed `next-intl` package
- Created `messages/en.json` with common, upload, convert, settings sections
- Created `src/i18n/request.ts` with getRequestConfig for locale loading
- Created `src/i18n/routing.ts` with defineRouting configuration (locales: ['en'], defaultLocale: 'en')
- Created `src/middleware.ts` for locale routing using createMiddleware
- Updated `next.config.ts` with createNextIntlPlugin wrapper
- Wrapped app layout with NextIntlClientProvider using getLocale() and getMessages()
- Verified typecheck passes with `npm run build`

**Learnings:**
- next-intl requires both routing.ts and request.ts configuration files
- createNextIntlPlugin takes path to request.ts as argument
- NextIntlClientProvider requires async layout function with getLocale() and getMessages() from 'next-intl/server'
- Next.js 16.1.1 shows deprecation warning for "middleware" file convention, recommending "proxy" instead

---

### Iteration 5 - US-005: Define TypeScript types for file conversion
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/types/index.ts` with all required type definitions
- Defined `ConversionStatus` type: 'pending' | 'converting' | 'complete' | 'error'
- Defined `ConvertibleFile` interface with all required properties (id, file, name, size, from, to, status, progress, error, result)
- Defined `FormatInfo` interface with name, extensions, mimeTypes, category, canConvertTo
- Defined `QualitySettings` interface with mode, quality, bitrate?, sampleRate?
- Added `FormatCategory` type for better type safety
- Added `QualityMode` type for better type safety
- Verified typecheck passes with `npm run build`

**Learnings:**
- Added helper types (FormatCategory, QualityMode) to make the code more readable and maintainable
- All types documented with JSDoc comments for better IDE support

---

### Iteration 6 - US-006: Create format registry for images
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/formats/image-formats.ts` with IMAGE_FORMATS array
- Defined 40 image formats with FormatInfo for each:
  - Web formats: PNG, JPEG, WebP, GIF, BMP
  - Professional: TIFF, ICO, SVG, PSD
  - Modern: AVIF, JPEG XL, HEIC, HEIF
  - RAW camera: NEF, CR2, CR3, ARW, DNG, ORF, RAF, RW2, PEF, SRW, ERF, NRW, KDC, DCR, MRW, 3FR, X3F
  - Other: TGA, PCX, PPM, PGM, PBM, PAM, XBM, XPM, EXR, HDR
- Each format has correct extensions, mimeTypes, and canConvertTo arrays
- Verified typecheck passes with `npm run build`

**Learnings:**
- Created COMMON_OUTPUT_FORMATS constant to reduce duplication for read-only formats
- RAW camera formats and some others are read-only (can convert FROM but not TO)

---

### Iteration 7 - US-007: Create format registry for audio
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/formats/audio-formats.ts` with AUDIO_FORMATS array
- Defined 10 audio formats with FormatInfo for each:
  - Common: MP3, WAV, OGG Vorbis, FLAC, AAC, M4A, Opus
  - Microsoft: WMA (read-only for output)
  - Apple/Professional: AIFF, ALAC
- Each format has correct extensions, mimeTypes, and canConvertTo arrays
- WMA is treated as input-only format (can convert FROM but limited output support)
- Verified typecheck passes with `npm run build`

**Learnings:**
- Followed same pattern as image-formats.ts with COMMON_AUDIO_OUTPUT_FORMATS constant
- Some formats like WMA have licensing restrictions, so they're input-only

---

### Iteration 8 - US-008: Create format registry for documents
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/formats/document-formats.ts` with DOCUMENT_FORMATS array
- Defined 12 document formats with FormatInfo for each:
  - PDF (Portable Document Format) - with limited output options
  - Microsoft Word: DOCX, DOC
  - Plain text: Markdown (md), Plain Text (txt)
  - Web: HTML
  - E-book: EPUB
  - OpenDocument: ODT
  - Rich Text: RTF
  - Technical: LaTeX, reStructuredText (rst), AsciiDoc
- Each format has correct extensions, mimeTypes, and canConvertTo arrays
- PDF has limited conversion options (to txt, html, md only)
- Verified typecheck passes with `npm run build`

**Learnings:**
- PDF is primarily a read format with limited output capabilities in Pandoc
- Some formats like LaTeX have multiple common extensions (tex, latex)
- AsciiDoc uses multiple extensions: adoc, asciidoc, asc

---

### Iteration 9 - US-009: Create unified format utilities
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/formats/index.ts` with unified format utilities
- Exported `ALL_FORMATS` combining IMAGE_FORMATS, AUDIO_FORMATS, and DOCUMENT_FORMATS (62+ formats total)
- Implemented `detectFormat(file: File)` - detects format by extension first, then falls back to MIME type
- Implemented `getConvertibleFormats(from: FormatInfo)` - returns array of FormatInfo objects for valid output formats
- Implemented `getFormatByExtension(ext: string)` - finds format by extension (handles dot prefix and case)
- Implemented `getFormatsByCategory(category: string)` - filters formats by category ('image', 'audio', 'document')
- Re-exported individual format arrays for convenience
- Verified typecheck passes with `npm run build`

**Learnings:**
- Used type guard `filter((format): format is FormatInfo => format !== null)` to properly type-narrow filtered results
- Accepted both `FormatCategory` and `string` for category parameter for flexibility

---

### Iteration 10 - US-010: Create conversion store with Zustand
**Status:** ✅ SUCCESS
**What was done:**
- Installed `zustand` and `immer` packages
- Created `src/store/conversion-store.ts` with full state management
- Defined state shape: { files: ConvertibleFile[], isConverting: boolean, globalSettings: QualitySettings }
- Implemented all required actions:
  - `addFiles(files: File[])` - adds files with auto-generated IDs and detected format
  - `removeFile(id: string)` - removes file by ID
  - `updateFile(id: string, updates)` - partial update of file properties
  - `setOutputFormat(id: string, format)` - sets target format for a file
  - `setGlobalSettings(settings)` - updates global quality settings
  - `startConversion()` - marks pending files as converting
  - `clearAll()` - clears all files and resets state
- Used immer middleware for immutable state updates
- Verified typecheck passes with `npm run build`

**Learnings:**
- Zustand with immer: import from 'zustand/middleware/immer' for immer middleware
- Use `set((state) => { state.prop = value })` pattern with immer for mutations
- generateId() helper for unique file IDs using timestamp + random string

---

### Iteration 11 - US-011: Setup ImageMagick WASM loader
**Status:** ✅ SUCCESS
**What was done:**
- Installed `@imagemagick/magick-wasm` package (v0.0.37)
- Created `src/lib/converters/magick-loader.ts`
- Implemented `initializeMagick()` async function that loads WASM from jsDelivr CDN
- Exported `isMagickReady` boolean flag, updated after successful initialization
- Added proper error handling and logging with detailed error messages
- Added initialization deduplication to prevent multiple concurrent init calls
- Added helper functions: `checkMagickReady()` and `resetMagickState()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- @imagemagick/magick-wasm v0.0.37 exports `initializeImageMagick(wasmLocation)` that accepts URL, ByteArray, or WebAssembly.Module
- Use jsDelivr CDN (cdn.jsdelivr.net/npm/...) for reliable WASM binary delivery
- Need to track initialization state with multiple flags (isInitializing, isMagickReady, initPromise) to handle concurrent calls

---

### Iteration 12 - US-012: Create ImageMagick converter class
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/converters/image-converter.ts`
- Implemented `convertImage(file: File, toFormat: string, quality: number): Promise<Blob>` function
- Used ImageMagick.read() static method to read source bytes into an image
- Used image.write() method with target MagickFormat to write converted data
- Defined FORMAT_MAP to map lowercase extensions to MagickFormat constants (png, jpeg, jpg, webp, gif, bmp, tiff, tif)
- Defined MIME_TYPE_MAP for correct output blob MIME types
- Applied quality setting for lossy formats (jpeg, jpg, webp) via image.quality property
- Added helper functions: `isSupportedOutputFormat()`, `getSupportedOutputFormats()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- Static `read()` method is on `ImageMagick` class, not `MagickImage` class
- ImageMagick.read() uses a callback pattern where the callback receives the IMagickImage instance
- image.write(format, callback) returns data via callback, need to copy Uint8Array before it goes out of scope
- MagickFormat is an object with format constants (e.g., MagickFormat.Png, MagickFormat.Jpeg)

---

### Iteration 13 - US-013: Extend ImageConverter for advanced formats
**Status:** ✅ SUCCESS
**What was done:**
- Added ICO output support (MagickFormat.Ico, image/x-icon)
- Added AVIF output support (MagickFormat.Avif, image/avif)
- Added JXL (JPEG XL) output support (MagickFormat.Jxl, image/jxl)
- Added HEIC/HEIF input support (read-only) via INPUT_ONLY_FORMATS map
- Added RAW camera format input support: NEF, CR2, CR3, ARW, DNG, ORF, RAF, RW2, PEF, SRW
- Updated LOSSY_FORMATS to include avif and jxl for quality settings
- Added helper functions: `isSupportedInputFormat()`, `getInputOnlyFormats()`, `getAllSupportedInputFormats()`, `isHeicFormat()`, `isRawFormat()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- MagickFormat has constants for modern formats: Avif, Jxl, Heic, Heif
- MagickFormat has constants for RAW formats: Nef, Cr2, Cr3, Arw, Dng, Orf, Raf, Rw2, Pef, Srw
- Separated FORMAT_MAP (output formats) and INPUT_ONLY_FORMATS (read-only formats) for clearer architecture
- AVIF and JXL are lossy formats that benefit from quality settings

---

### Iteration 14 - US-014: Setup FFmpeg WASM for audio
**Status:** ✅ SUCCESS
**What was done:**
- Installed `@ffmpeg/ffmpeg` (v0.12.15) and `@ffmpeg/util` packages
- Created `src/lib/converters/ffmpeg-loader.ts`
- Implemented `initializeFFmpeg(): Promise<FFmpeg>` async function
- Loads FFmpeg core from jsDelivr CDN using toBlobURL for CORS-safe loading
- Exported `isFFmpegReady` boolean flag, updated after successful initialization
- Added `checkSharedArrayBufferSupport()` and `checkCrossOriginIsolation()` functions
- Warns user if SharedArrayBuffer is unavailable (requires COOP/COEP headers)
- Added helper functions: `getFFmpegInstance()`, `checkFFmpegReady()`, `terminateFFmpeg()`, `resetFFmpegState()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- @ffmpeg/ffmpeg v0.12.15 uses FFmpeg class with load() method accepting coreURL, wasmURL, workerURL
- Use @ffmpeg/util's toBlobURL() to convert CDN URLs to blob URLs (avoids CORS and MIME type issues)
- FFmpeg requires SharedArrayBuffer for multi-threading; check window.crossOriginIsolated for header presence
- Worker is optional and only used when SharedArrayBuffer is available

---

### Iteration 15 - US-015: Create Audio converter function
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/converters/audio-converter.ts`
- Implemented `convertAudio(file: File, toFormat: string, settings: QualitySettings): Promise<Blob>`
- Created FORMAT_CONFIG map with codec settings for MP3, WAV, OGG, FLAC, AAC, M4A
- Writes input file to FFmpeg virtual FS and reads output after conversion
- Builds FFmpeg command with `-c:a` for codec, `-b:a` for bitrate, `-ar` for sample rate
- Applies bitrate from settings or calculates from quality (1-100 maps to 64-320 kbps)
- Cleans up temporary files in virtual filesystem after conversion
- Added helper functions: `isSupportedAudioOutputFormat()`, `getSupportedAudioOutputFormats()`, `getAudioMimeType()`
- Verified typecheck passes with `npm run build`

**Learnings:**
- FFmpeg.readFile() returns Uint8Array which may have SharedArrayBuffer backing; use `new Uint8Array(data).buffer` to get clean ArrayBuffer for Blob creation
- FFmpeg virtual FS needs explicit writeFile() before exec() and readFile() after
- Always clean up virtual FS files in finally block to prevent memory leaks

---

### Iteration 16 - US-016: Extend AudioConverter for all formats
**Status:** ✅ SUCCESS
**What was done:**
- Added OPUS output support using libopus codec (extension: opus, mimeType: audio/opus)
- Added WMA output support using wmav2 codec (extension: wma, mimeType: audio/x-ms-wma)
- Added AIFF output support using pcm_s16be codec (extensions: aiff/aif, mimeType: audio/aiff)
- Added ALAC output support using alac codec in m4a container (extension: m4a with ipod container, mimeType: audio/mp4)
- Updated BITRATE_SUPPORTED_FORMATS to include opus and wma
- Added container format support in buildFFmpegArgs for ALAC (uses -f ipod flag)
- Sample rate (-ar) was already implemented in US-015
- Verified typecheck passes with `npm run build`

**Learnings:**
- ALAC (Apple Lossless Audio Codec) requires m4a container specified via `-f ipod` in FFmpeg
- WMA and OPUS both support bitrate settings like MP3/AAC/OGG
- AIFF uses pcm_s16be (16-bit signed big-endian PCM) codec, similar to WAV but with different byte order

---

### Iteration 17 - US-017: Setup Pandoc WASM for documents
**Status:** ✅ SUCCESS
**What was done:**
- Installed `pandoc-wasm` npm package (v0.0.2) which bundles Pandoc compiled for WebAssembly
- Created `src/lib/converters/pandoc-loader.ts` following the same pattern as magick-loader.ts and ffmpeg-loader.ts
- Implemented `initializePandoc(): Promise<void>` async function that initializes the Pandoc WASM binary
- Exported `isPandocReady` boolean flag, updated after successful initialization
- Added helper functions: `getPandocInstance()`, `checkPandocReady()`, `resetPandocState()`
- Added version logging during initialization for debugging
- Verified typecheck passes with `npm run build`

**Learnings:**
- pandoc-wasm npm package bundles the WASM binary internally and loads it via init() method
- No manual wasm download needed - the package handles fetching from its bundled gzipped wasm files
- Pandoc class provides: init(), run(params), getVersion() methods
- run() accepts { text, options: { from, to }, files?, citeproc? } parameters

---

### Iteration 18 - US-018: Create Document converter function
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/converters/document-converter.ts` with full document conversion functionality
- Implemented `convertDocument(file: File, toFormat: string): Promise<Blob>` function
- Created INPUT_FORMAT_MAP and OUTPUT_FORMAT_MAP for Pandoc format name mapping
- Supports text-based conversions: MD → HTML/DOCX/TXT, HTML → MD/TXT, TXT → MD/HTML, etc.
- Added MIME_TYPES map for correct output blob MIME types
- Added helper functions: `isSupportedDocumentInputFormat()`, `isSupportedDocumentOutputFormat()`, `getSupportedDocumentInputFormats()`, `getSupportedDocumentOutputFormats()`, `getDocumentMimeType()`
- Note: PDF output is not supported in browser (requires LaTeX engine)
- Verified typecheck passes with `npm run build`

**Learnings:**
- Pandoc WASM cannot generate PDF directly (requires LaTeX engine or wkhtmltopdf)
- Pandoc run() returns string for text-based output formats
- Input format is auto-detected from file extension using detectInputFormat() helper
- Pandoc format names differ from file extensions (e.g., 'plain' for txt, 'markdown' for md)

---

### Iteration 19 - US-019: Extend DocumentConverter for all formats
**Status:** ✅ SUCCESS
**What was done:**
- Added EPUB output support with base64 decoding for binary format
- Added ODT output support with base64 decoding for binary format
- Added RTF output support (text format)
- Added LaTeX output support (tex/latex extensions)
- Added RST (reStructuredText) support for both input and output
- Added AsciiDoc support for both input and output (adoc/asciidoc/asc extensions)
- Added `BINARY_OUTPUT_FORMATS` set to identify formats that return base64-encoded strings
- Added `isBinaryOutputFormat()` helper function
- Added `base64ToArrayBuffer()` helper function for decoding base64 to ArrayBuffer (avoiding SharedArrayBuffer type issues)
- Updated `convertDocument()` to handle binary output formats differently from text formats
- Verified typecheck passes with `npm run build`

**Learnings:**
- Pandoc WASM returns binary formats (DOCX, EPUB, ODT) as base64-encoded strings
- Text formats (RTF, LaTeX, RST, AsciiDoc) are returned as plain strings
- TypeScript strict mode requires using `new ArrayBuffer()` explicitly rather than getting buffer from Uint8Array to avoid SharedArrayBuffer type incompatibility with BlobPart
- Create a new ArrayBuffer explicitly and copy bytes into it for Blob compatibility

---

### Iteration 20 - US-020: Create unified Converter facade
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/lib/converters/index.ts` as the unified entry point for all conversions
- Implemented `convert(file: ConvertibleFile, onProgress?, settings?): Promise<Blob>` function
- Created `detectCategory()` helper function that determines category from file format or MIME type
- Routing logic for image → convertImage, audio → convertAudio, document → convertDocument
- Progress callback called at 0%, 10%, and 100% during conversion
- Added `getConverterStatus()` function to check which converters are ready
- Added `initializeAllConverters()` function for preloading all WASM libraries at startup
- Re-exported individual converters and loaders for direct access when needed
- Verified typecheck passes with `npm run build`

**Learnings:**
- Using `detectFormat()` from formats utility provides category information from FormatInfo
- Fallback to MIME type prefix (image/, audio/, text/) when format detection fails
- Document converter doesn't need quality settings, but image and audio do
- Re-exports allow consumers to import from a single module while maintaining access to internals

---

### Iteration 21 - US-021: Create Web Worker for conversions
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/workers/conversion-worker.ts` for running conversions in a separate thread
- Worker receives messages: `{ type: 'convert', file: File, from: string, to: string, settings: QualitySettings }`
- Worker posts progress updates: `{ type: 'progress', progress: number }`
- Worker posts completion: `{ type: 'complete', blob: Blob }` or `{ type: 'error', error: string }`
- Created `src/lib/converters/worker-client.ts` with `runConversion()` function that wraps Worker communication
- Added `isWorkerSupported()` helper to check Web Worker availability
- Added `convertWithWorkerFallback()` for graceful degradation when workers aren't available
- Verified typecheck passes with `npm run build`

**Learnings:**
- Web Workers use `new Worker(new URL('@/workers/...', import.meta.url), { type: 'module' })` pattern for ES module workers in Next.js
- Type definitions should be exported at declaration (not re-exported at end) to avoid duplicate export errors
- Worker client should terminate workers after completion to free resources
- Fallback to main thread conversion provides graceful degradation for environments without Worker support

---

### Iteration 22 - US-022: Create color theme and CSS variables
**Status:** ✅ SUCCESS
**What was done:**
- Updated `src/app/globals.css` with gradient CSS variables
- Added light mode variables: --gradient-start (purple), --gradient-end (magenta), --gradient-accent (cyan)
- Added dark mode variables with more vibrant colors for better contrast on dark backgrounds
- Created gradient utility classes:
  - `.gradient-bg` - static gradient background
  - `.gradient-bg-animated` - animated shifting gradient background
  - `.gradient-text` - gradient text effect using background-clip
  - `.gradient-text-animated` - animated gradient text effect
  - `.gradient-border` - gradient border using pseudo-element technique
  - `.gradient-border-animated` - animated gradient border
- Added `@keyframes gradient-shift` animation (8s ease infinite)
- Added `@keyframes gradient-rotate` for future use
- Included `prefers-reduced-motion: reduce` support for accessibility
- Verified typecheck passes with `npm run build`

**Learnings:**
- Use oklch color space for consistent, perceptually uniform gradient colors
- Gradient border technique uses pseudo-element with mask to create border effect
- Animation should use background-size: 300% with shifting position for smooth loops
- Always include prefers-reduced-motion media query for accessibility

---

### Iteration 23 - US-023: Create app layout with Header
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/layout/Header.tsx` with client-side theme management
- Displayed "aepoconvert" logo with gradient-text class (purple/pink gradient)
- Added theme toggle button with Sun/Moon icons from lucide-react
- lucide-react was already installed (no additional install needed)
- Header is sticky (top-0, z-50) with backdrop-blur-md effect
- Updated `src/app/layout.tsx` to import and include Header component
- Added `<main>` wrapper with min-height calculation for content area
- Verified typecheck passes with `npm run build`
- Verified visually in browser: light mode, dark mode toggle, and sticky behavior all working

**Learnings:**
- Theme toggle pattern: use useState for isDark, update document.documentElement.classList and localStorage
- Use mounted state to prevent hydration mismatch when checking initial theme
- Check both localStorage and system preference (prefers-color-scheme) for initial theme
- backdrop-blur works well with bg-background/80 for semi-transparent sticky header

---

### Iteration 24 - US-024: Create DropZone component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/upload/DropZone.tsx` with drag-and-drop functionality
- Large rectangular drop area with min-height: 200px
- Dashed border (border-dashed) with rounded corners (rounded-xl)
- Upload icon from lucide-react in circular background
- "Drop files here or click to browse" text with subtitle
- Hidden file input with multiple attribute for multi-file selection
- onDrop, onClick, onDragOver handlers with proper event handling
- Added accessibility: role="button", tabIndex, aria-label, keyboard navigation (Enter/Space)
- Fixed i18n routing: created [locale] folder structure with layout.tsx and page.tsx
- Updated root layout to delegate to locale layout
- Verified typecheck passes with `npm run build`
- Verified visually in browser: drop zone renders correctly with all elements

**Learnings:**
- next-intl middleware redirects `/` to `/en` but requires `[locale]` folder structure
- Root layout should return `children` directly when using locale-based layouts
- For accessibility, DropZone should have role="button", tabIndex, aria-label, and keyboard handlers
- Reset file input value after selection to allow re-selecting same file

---

### Iteration 25 - US-025: Add drag-over visual feedback to DropZone
**Status:** ✅ SUCCESS
**What was done:**
- Added `isDragging` state using useState hook to track drag state
- Added `dragCounter` ref to properly handle nested drag events (prevents flicker)
- Implemented `handleDragEnter` handler that increments counter and sets isDragging=true
- Implemented `handleDragLeave` handler that decrements counter and sets isDragging=false when counter reaches 0
- Updated `handleDrop` to reset dragCounter and isDragging state
- Added visual feedback when isDragging:
  - Border changes to accent color: `border-primary`
  - Background lightens: `bg-primary/10`
  - Subtle scale transform: `scale-[1.02]`
- Changed transition to `transition-all` for smooth animation of all properties
- Verified typecheck passes with `npm run build`
- Verified component renders correctly in browser

**Learnings:**
- Use dragCounter ref pattern to handle nested drag events - dragEnter fires for each child element
- Only set isDragging=true when counter becomes 1, set to false when counter returns to 0
- Reset counter to 0 in handleDrop to ensure clean state after drop
- transition-all with duration-200 and ease-out provides smooth visual feedback

---

### Iteration 26 - US-026: Add file type validation to DropZone
**Status:** ✅ SUCCESS
**What was done:**
- Added file filtering by supported extensions using `detectFormat()` from formats utility
- Imported `toast` from sonner for error notifications
- Implemented logic to separate supported and unsupported files
- Show descriptive toast.error() for unsupported files with file names
- Configured Toaster component in `src/app/[locale]/layout.tsx`
- Added `getAcceptedExtensions()` helper to display first 15 extensions + count of remaining
- Added `getAcceptAttribute()` helper to generate accept attribute for file input
- Added hint text showing accepted file types below the drop zone subtitle
- Added `accept` attribute to file input for browser-level filtering
- Verified typecheck passes with `npm run build`
- Verified component renders correctly in browser with Playwright

**Learnings:**
- sonner toast is already configured as shadcn/ui component (replaces deprecated toast)
- Use `toast.error(title, { description })` pattern for rich error messages
- Generate accept attribute from ALL_FORMATS to dynamically support all registered formats
- Show first 15 extensions in hint text to keep it readable, with "+ more" count for remaining

---

### Iteration 27 - US-027: Create FileCard component
**Status:** SUCCESS
**What was done:**
- Created `src/components/files/FileCard.tsx` component
- Props: file: ConvertibleFile, onRemove: () => void, onFormatChange: (format: string) => void
- Display file type icon based on category using lucide-react (FileImage, FileAudio, FileText, File)
- Show truncated file name preserving extension (truncateFileName helper)
- Format file size as human-readable KB/MB/GB (formatFileSize helper)
- Display detected format as Badge with category-based variant (default/secondary/outline)
- Remove button (X icon) in top-right corner with hover effects (opacity + destructive color)
- Uses shadcn Card component with subtle shadow and hover:shadow-md transition
- Verified typecheck passes with `npm run build`
- Verified component renders correctly in browser with Playwright screenshot

**Learnings:**
- Use lucide-react icons: FileImage, FileAudio, FileText for category-based file icons
- truncateFileName should preserve file extension when truncating long names
- formatFileSize: use Math.log to calculate appropriate unit (B, KB, MB, GB, TB)
- Badge variant can vary by category for visual distinction between file types

---

### Iteration 28 - US-028: Create FormatSelector component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/files/FormatSelector.tsx` component
- Props: currentFormat: string, availableFormats: FormatInfo[], onSelect: (format: string) => void
- Used shadcn Select component (SelectTrigger, SelectContent, SelectGroup, SelectItem, SelectLabel)
- Groups formats by category (image, audio, document) using SelectGroup with SelectLabel
- Shows format extension (uppercase) and format name in each SelectItem
- Added aria-label for accessibility
- Verified typecheck passes with `npm run build`
- Verified component renders and works correctly in browser with Playwright

**Learnings:**
- Use `reduce<Record<FormatCategory, FormatInfo[]>>` to group formats by category
- Filter out empty categories before rendering to avoid empty groups
- SelectLabel provides category headers within SelectGroup
- SelectValue can have custom content for displaying selected format

---

### Iteration 29 - US-029: Create ConversionProgress component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/files/ConversionProgress.tsx` component
- Props: status: ConversionStatus, progress: number, error: string | null
- Implemented four visual states:
  - Pending: Gray dot with "Waiting to convert" text
  - Converting: Spinner icon, percentage text, animated gradient progress bar with shimmer effect
  - Complete: Green checkmark in circle with "Complete" text
  - Error: Red alert icon with "Error" text and error message below
- Added `@keyframes shimmer` animation to globals.css for progress bar shimmer effect
- Used lucide-react icons: Loader2 (spinner), Check (checkmark), AlertCircle (error)
- Applied gradient-bg-animated class to progress bar fill
- Verified typecheck passes with `npm run build`
- Verified all four states render correctly in browser with Playwright screenshot

**Learnings:**
- Custom progress bar with gradient animation uses gradient-bg-animated class on inner div
- Shimmer effect overlay uses absolute positioning with translateX animation
- Use consistent sizing for status icons (h-5 w-5 container, h-3 w-3 icon)
- line-clamp-2 utility truncates error messages that are too long

---

### Iteration 30 - US-030: Create FileList component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/files/FileList.tsx` component
- Reads files from conversion store using useConversionStore hook
- Renders FileCard for each file with responsive CSS grid layout
- Grid: 1 column on mobile, 2 columns on sm (640px+), 3 columns on lg (1024px+)
- Empty state: shows FileX icon with "No files added yet" message and helpful subtitle
- Updated page.tsx to include FileList component
- Wired DropZone onFilesSelected to store's addFiles action
- Verified typecheck passes with `npm run build`
- Verified component works in browser: file upload displays FileCard, remove returns to empty state

**Learnings:**
- FileX icon from lucide-react works well for empty state visual
- Responsive grid uses `grid-cols-1 sm:grid-cols-2 lg:grid-cols-3` for progressive columns
- Early wiring of DropZone to store (via page.tsx) helps verify FileList functionality

---

### Iteration 31 - US-031: Add animations to FileList
**Status:** ✅ SUCCESS
**What was done:**
- Installed `framer-motion` package
- Imported motion and AnimatePresence from framer-motion
- Wrapped FileCard in motion.div with layout animation enabled
- Added enter animation: fade in (opacity 0→1) + slide up (y 20→0)
- Added exit animation: fade out (opacity 1→0) + slide up (y 0→-20)
- Used AnimatePresence with mode="popLayout" for proper exit animations
- Added fade-in animation to empty state for smoother transitions
- Verified typecheck passes with `npm run build`
- Verified animations work in browser: file entry, file removal, and empty state transitions all animated

**Learnings:**
- framer-motion's AnimatePresence requires mode="popLayout" or mode="wait" for exit animations in grid layouts
- motion.div with layout prop enables smooth grid rearrangement when items are added/removed
- Use easeOut timing function for natural-feeling animations (0.3s duration)
- Empty state can also benefit from a simple fade-in animation for polish

---

### Iteration 32 - US-032: Create SimpleQualitySettings component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/settings/SimpleQualitySettings.tsx` component
- Defined QUALITY_PRESETS constant with three options: Low (60%), Medium (80%), High (95%)
- Each preset has a label, value, and description
- Three Button components in a row using flex layout with gap-2
- Visual selection indicator: default variant (filled) when selected, outline variant when not
- Added ring-2 ring-primary/20 for extra visual feedback on selected button
- aria-pressed attribute for accessibility
- Updates global settings in store via setGlobalSettings({ quality, mode: 'simple' })
- Description updates dynamically based on selected preset
- Verified typecheck passes with `npm run build`
- Verified all three buttons work correctly in browser with selection state and description updates

**Learnings:**
- Use `variant={isSelected ? "default" : "outline"}` pattern for toggle button groups
- aria-pressed attribute communicates selection state to screen readers
- Show description for currently selected option rather than all at once for cleaner UI
- Use flex-1 on buttons to make them equal width in the row

---

### Iteration 33 - US-033: Create AdvancedQualitySettings component
**Status:** ✅ SUCCESS
**What was done:**
- Enhanced `AdvancedQualitySettings` with current value labels for quality, bitrate, and sample rate
- Added accessibility labels for the selects and kept store updates in advanced mode on every change
- Verified typecheck passes via `npm run build` (network access needed for next/font Google Fonts fetch)

**Learnings:**
- next/font build requires network access to download Google Fonts; rerun build with network permissions when restricted
- Showing current numeric values beside controls clarifies advanced settings state at a glance

---

### Iteration 35 - US-035: Create ConvertButton component
**Status:** ✅ SUCCESS
**What was done:**
- Added `src/components/actions/ConvertButton.tsx` with a large gradient primary action button
- Shows file count badge when files are present and disables when no files or a conversion is already running
- Displays a Loader2 spinner during conversion and triggers `startConversion()` on click
- Includes optional className prop for flexible placement in future action rows
- Verified typecheck passes with `npm run build`

**Learnings:**
- The `gradient-bg-animated` utility pairs well with the shadcn Button focus/spacing defaults to create a standout primary action
- Centralizing enable/disable state from the store (files length, isConverting) keeps button behavior aligned with global conversion status

---

### Iteration 36 - US-036: Create DownloadButton component
**Status:** ✅ SUCCESS
**What was done:**
- Installed `jszip` and added `src/components/actions/DownloadButton.tsx` that renders only when completed files exist
- Single-file downloads use the original filename with the new extension; multi-file downloads are packed into `aepoconvert-files.zip` with unique names
- Added animated checkmark badge, ZIP/download sublabel, and disabled loading state while generating archives
- Verified typecheck passes with `npm run build`

**Learnings:**
- JSZip accepts Blob objects directly, making it straightforward to stream converted results into an archive
- Building filenames with a Set prevents duplicate names when batching downloads
- Releasing object URLs shortly after triggering the anchor click avoids memory leaks in repeated downloads

---

### Iteration 37 - US-037: Create ClearAllButton component
**Status:** ✅ SUCCESS
**What was done:**
- Added `src/components/actions/ClearAllButton.tsx` with a ghost/outline aesthetic, dashed border, and accent hover glow
- Implemented a confirmation dialog (shadcn Dialog) with destructive/cancel actions before clearing all files
- Wired the confirm action to the store’s `clearAll()` and hide the button when no files are present
- Verified typecheck passes with `npm run build`

**Learnings:**
- Wrapping the trigger Button with Dialog provides a clean confirmation flow without extra state plumbing
- Light dashed outlines plus subtle glow give destructive actions emphasis while keeping them secondary to primary CTAs

---

### Iteration 38 - US-038: Assemble main page layout
**Status:** ✅ SUCCESS
**What was done:**
- Rebuilt `src/app/[locale]/page.tsx` into layered sections with gradient glows and glassy panels for clearer hierarchy
- Ordered the page as DropZone → FileList → SettingsPanel → action row inside a centered max-w-4xl container with mobile/desktop spacing (gap-4, sm:gap-6)
- Added action row with ConvertButton, DownloadButton (wired to store files), and ClearAllButton in a responsive flex layout
- Verified typecheck via `npm run build`

**Learnings:**
- Using light gradient orbs plus subtle borders/backdrop blur keeps focus on core components without redesigning them
- Combining gap utilities (gap-4 with sm:gap-6) cleanly satisfies mobile vs desktop spacing requirements in one stack

---

### Iteration 39 - US-039: Wire up file upload to store
**Status:** ✅ SUCCESS
**What was done:**
- DropZone now dispatches the conversion store’s `addFiles()` action directly for both drag-and-drop and file input selection, removing the need for parent wiring
- The conversion store now auto-detects each file’s format via `detectFormat()` and stores a canonical extension for the `from` field before queuing files
- Confirmed files appear immediately in FileList and typecheck passes with `npm run build`

**Learnings:**
- Using `detectFormat()` to choose between the canonical extension and the original filename extension keeps format metadata consistent across future format lookups
- Having DropZone call the store directly avoids missed callbacks and guarantees uploads surface in the UI as soon as they’re added

---

### Iteration 40 - US-040: Wire up format selection to store
**Status:** ✅ SUCCESS
**What was done:**
- Conversion store now assigns a default output format when adding files by choosing the first compatible extension (preferring one different from the source)
- FileList passes each file’s convertible formats into FileCard, which now surfaces a FormatSelector tied to the stored `file.to` value
- FormatSelector handles missing outputs gracefully and TypeScript checks pass with `npm run build`

**Learnings:**
- Preferring a convertible format that differs from the source avoids no-op defaults while still falling back when only one option exists
- Keeping the selector inside each FileCard makes the selected output format visible alongside other file metadata

---

### Iteration 41 - US-041: Wire up conversion to workers
**Status:** ✅ SUCCESS
**What was done:**
- startConversion now guards against concurrent runs, marks pending files as converting, and snapshots quality settings for consistent runs
- Each pending file is sent through convertWithWorkerFallback, updating per-file progress from worker messages
- Successful conversions store the resulting blob and mark status complete; failures record an error state without breaking other conversions
- isConverting resets once all conversions settle to re-enable the Convert button

**Learnings:**
- Taking a settings snapshot per run prevents mid-conversion UI tweaks from desynchronizing worker parameters
- Promise.allSettled ensures the converting flag clears even when some files fail
- Progress callbacks should ignore removed/non-converting files to avoid stale state writes

---

### Iteration 42 - US-042: Wire up download functionality
**Status:** ✅ SUCCESS
**What was done:**
- Verified DownloadButton already implemented triggerDownload() with object URL creation and anchor click download
- Verified buildFilename() uses original name with new extension from file.to
- Verified downloadZip() uses JSZip to create archive named "aepoconvert-files.zip"
- Verified object URLs are revoked after 2 seconds via setTimeout
- Fixed infinite loop bug in ConvertButton and ClearAllButton caused by Zustand selector returning new object on each render
- Added `useShallow` from 'zustand/react/shallow' to prevent unnecessary re-renders
- Typecheck passes and app works correctly in browser

**Learnings:**
- Zustand selectors that return objects `(state) => ({ a: state.a, b: state.b })` cause infinite re-renders because a new object is created each time
- Use `useShallow` wrapper from 'zustand/react/shallow' for object selectors to enable shallow comparison
- Alternative: select individual values with separate useConversionStore calls for each value

---

### Iteration 43 - US-043: Add toast notifications for actions
**Status:** ✅ SUCCESS
**What was done:**
- Added toast.success() in DropZone.tsx when files are added, showing file count and names
- Added toast.loading() in conversion-store.ts when conversion starts with "Converting X file(s)..."
- Added toast.success() for successful conversions with "Conversion complete!" and count
- Added toast.warning() for mixed results showing success and error counts
- Added toast.error() for failed conversions with error message
- Used sonner's toast ID feature to update the loading toast to success/error on completion
- Verified typecheck passes with `npm run build`
- Verified all toasts work correctly in browser with Playwright

**Learnings:**
- Use toast ID (`id: 'conversion-progress'`) to update the same toast from loading to success/error
- toast.loading() creates a persistent loading indicator until dismissed or updated
- Using `get()` in Zustand allows reading current state after async operations complete

---

### Iteration 44 - US-044: Add drag-over overlay to whole page
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/layout/DragOverlay.tsx` with full-screen overlay (z-50)
- Shows when files dragged over window using window-level drag event listeners
- Uses dragCounter ref pattern to handle nested drag events correctly
- Animated gradient background (gradient-bg-animated) with 30% opacity and backdrop blur
- Upload icon with pulse animation in primary-colored circle
- "Drop files to convert" gradient text heading with subtitle
- Dashed border visual indicator around the overlay
- Handles file drops with format validation and toast notifications
- Hides on drag-leave (counter reaches 0) or drop (counter reset to 0)
- Added DragOverlay to layout.tsx
- Verified typecheck passes with `npm run build`
- Verified overlay shows/hides correctly in browser with Playwright

**Learnings:**
- Window-level drag events allow detecting drags anywhere on the page, not just specific dropzones
- The dragCounter ref pattern prevents flicker from nested element drag events
- Check `e.dataTransfer?.types.includes('Files')` to only respond to file drags (not text drags)

---

### Iteration 45 - US-045: Add loading states for converter initialization
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/status/ConverterStatus.tsx` with loading/ready/error states
- Each converter (image, audio, document) initializes independently to track individual failures
- Shows Loader2 spinner during loading, checkmark icon when ready, AlertCircle for errors
- Icons use category-specific icons (ImageIcon, Music, FileText from lucide-react)
- Color-coded states: green for ready, red/destructive for error, muted for loading
- Tooltip on hover shows detailed status with labels and error messages
- Fixed position in bottom-right corner (z-40) with glassmorphism styling
- Added ConverterStatus to layout.tsx
- Verified typecheck passes with `npm run build`
- Verified all states work in browser with Playwright

**Learnings:**
- Initialize converters independently rather than using initializeAllConverters to track individual failures
- Dynamic imports with .then()/.catch() allow parallel initialization with error handling per converter
- FFmpeg requires SharedArrayBuffer which needs COOP/COEP headers (not available in dev without config)

---

### Iteration 46 - US-046: Create error handling for conversions
**Status:** ✅ SUCCESS
**What was done:**
- Updated FileCard to show red border (border-destructive border-2 bg-destructive/5) when status is 'error'
- Added error message display below file name with AlertCircle icon and destructive text styling
- Created retry button panel that replaces the format selector when in error state
- Retry button styled with destructive border/text and RotateCcw icon
- Added `retryFile(id)` action to conversion-store that resets status to 'pending', clears progress/error/result
- Wired retry functionality in FileList to pass onRetry callback to FileCard
- Verified typecheck passes with `npm run build`
- Verified all error states and retry functionality work correctly in browser with Playwright

**Learnings:**
- Use cn() utility with conditional class to apply error border styling dynamically
- Conditionally render different bottom panels (format selector vs retry) based on error state
- Retry action only works if file.status === 'error' to prevent accidental resets

---

### Iteration 47 - US-047: Add keyboard shortcuts
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/hooks/useKeyboardShortcuts.ts` with global keyboard event handling
- Implemented Ctrl/Cmd + V: paste files from clipboard using Clipboard API
- Implemented Ctrl/Cmd + Enter: start conversion (with guards for no files, already converting, no pending)
- Implemented Escape: clear all files with confirmation dialog state management
- Added hook to main page.tsx and integrated with keyboard-triggered confirmation dialog
- Dialog uses shadcn Dialog component with Cancel and Clear All buttons
- Added helper function `getKeyboardShortcutHints()` for displaying shortcuts in UI
- Verified typecheck passes with `npm run build`
- Verified all shortcuts work in browser: Escape shows dialog, Ctrl+Enter starts conversion

**Learnings:**
- Use navigator.clipboard.read() for accessing clipboard files (requires permission)
- Clipboard API returns ClipboardItem objects with types array for file detection
- Use dragCounter-like pattern to track confirmation dialog state (Escape toggles)
- Input/textarea elements should be excluded from keyboard shortcut handling

---

### Iteration 48 - US-048: Create Footer component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/layout/Footer.tsx` with privacy message and links
- Added green shield icon with "All conversions happen locally in your browser" text
- Added GitHub link icon pointing to project repository with hover effects
- Added dynamic copyright text using current year (© 2026 aepoconvert)
- Footer styled with border-top, backdrop-blur, and responsive flex layout
- Added Footer component to layout.tsx after main content
- Adjusted main min-height to account for header and footer (7rem total)
- Verified typecheck passes with `npm run build`
- Verified footer renders correctly in browser with Playwright screenshot

**Learnings:**
- Use contentinfo landmark role (footer element) for proper accessibility
- Dynamic year with `new Date().getFullYear()` keeps copyright current
- Responsive layout with `flex-col sm:flex-row` stacks on mobile, spreads on desktop

---

### Iteration 49 - US-049: Create PrivacyBadge component
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/status/PrivacyBadge.tsx` with ShieldCheck icon and "100% Private" text
- Used shadcn Tooltip component with TooltipProvider, TooltipTrigger, TooltipContent
- Tooltip shows "Your files never leave your device" with detailed explanation about WebAssembly processing
- Badge styled with green color scheme (border-green-500/20, bg-green-500/10, text-green-600)
- Added cursor-help for discoverability and hover:bg-green-500/15 for interactivity
- Placed PrivacyBadge above DropZone in the page layout with centered flex container
- Verified typecheck passes with `npm run build`
- Verified tooltip appears on hover in browser with Playwright screenshot

**Learnings:**
- TooltipProvider must wrap Tooltip for shadcn tooltip to work
- cursor-help indicates to users that the element has additional information
- Green color scheme (500/10, 500/20) works well for positive/secure messaging

---

### Iteration 50 - US-050: Create animated gradient background
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/layout/GradientBackground.tsx` with 5 animated gradient blobs
- Blobs positioned in corners (top-left, top-right, bottom-left, bottom-right) and center
- Each blob uses different gradient colors (purple/pink, cyan/blue, emerald/teal, orange/rose, violet/purple)
- Low opacity (0.05-0.15) via Tailwind opacity modifiers to not distract
- Fixed position with -z-10 to stay behind all content
- Added @keyframes blob and blob-slow animations to globals.css
- Added animation utility classes: animate-blob, animate-blob-slow, animation-delay-*
- Checks prefers-reduced-motion media query to disable animations when reduced motion preferred
- Added GradientBackground to layout.tsx at the start of NextIntlClientProvider
- Verified typecheck passes with `npm run build`
- Verified blobs visible in browser with Playwright screenshot

**Learnings:**
- Use aria-hidden="true" on decorative background elements for accessibility
- Animation delays create more organic, less synchronized movement between blobs
- pointer-events-none ensures background doesn't interfere with user interactions
- blur-3xl creates soft, dreamy blob edges perfect for ambient backgrounds

---

### Iteration 51 - US-051: Add micro-animations to UI elements
**Status:** ✅ SUCCESS
**What was done:**
- Updated button component with `hover:scale-[1.02] active:scale-[0.98]` transitions
- Added `duration-200` for smooth animation timing
- Added `disabled:hover:scale-100` to prevent scale on disabled buttons
- Card hover shadow was already implemented in FileCard (`hover:shadow-md transition-all`)
- Progress bar shimmer effect was already implemented in US-029 via CSS animation
- Added pop animation to output format badge in FileCard using framer-motion AnimatePresence
- Badge animates with scale 0.8→1 and opacity 0→1 when format changes
- Used framer-motion `mode="wait"` for smooth exit/enter transitions
- Verified typecheck passes with `npm run build`
- Verified animations work in browser

**Learnings:**
- Combine hover:scale and active:scale for tactile button feedback
- AnimatePresence with `mode="wait"` ensures exit animation completes before enter
- Key prop on motion elements triggers re-animation when value changes
- disabled:hover:scale-100 prevents awkward scaling on disabled elements

---

### Iteration 52 - US-052: Create responsive design for mobile
**Status:** ✅ SUCCESS
**What was done:**
- Updated DropZone with `min-h-[160px] sm:min-h-[200px]` for reduced height on mobile
- Added smaller icon (h-12 w-12 vs h-16 w-16) and text (text-base vs text-lg) on mobile
- Added responsive padding and gap (gap-3 sm:gap-4, py-6 sm:py-8)
- Hidden file extensions hint on mobile with `hidden sm:block` to reduce clutter
- FileList already had `grid-cols-1 sm:grid-cols-2 lg:grid-cols-3` for single column on mobile
- SettingsPanel already full width (uses container with rounded corners)
- Updated button sizes for touch: h-11 sm:h-9 (default), h-10 sm:h-8 (sm), h-12 sm:h-10 (lg)
- Icon button sizes also updated: size-11 sm:size-9, size-10 sm:size-8, size-12 sm:size-10
- Tested at 375px viewport width with Playwright screenshot
- Verified typecheck passes with `npm run build`

**Learnings:**
- Use `sm:` prefix for desktop overrides, mobile-first design is cleaner
- 44px (h-11) is minimum touch target size per Apple HIG and Google Material guidelines
- Hide non-essential text on mobile to reduce clutter while keeping functionality
- Use responsive breakpoints consistently: < 640px (mobile), >= 640px (sm), >= 1024px (lg)

---

### Iteration 53 - US-053: Add file size limits and warnings
**Status:** ✅ SUCCESS
**What was done:**
- Added file size constants: MAX_FILE_SIZE (2GB), LARGE_FILE_WARNING_SIZE (100MB), ESTIMATED_TIME_THRESHOLD (50MB)
- Added formatFileSize() helper function for human-readable file sizes (B, KB, MB, GB, TB)
- Added estimateConversionTime() function to estimate conversion duration (~5MB/s)
- Added formatDuration() helper for human-readable time estimates
- Updated DropZone.tsx handleFiles() to validate file sizes:
  - Block files > 2GB with error toast showing file size
  - Warn for files > 100MB with warning toast
  - Show info toast with estimated conversion time for files > 50MB
- Updated DragOverlay.tsx handleDrop() with identical file size validation logic
- File size displayed in human-readable format (verified: "9 B" for test file)
- Verified typecheck passes with `npm run build`
- Verified changes work in browser with Playwright

**Learnings:**
- Use consistent file size validation in both DropZone and DragOverlay for uniform UX
- Estimate conversion time at ~5MB/s as rough baseline (varies by format and settings)
- Track multiple categories separately: blocked (>2GB), large (>100MB), needs-estimate (>50MB)
- Show the largest file's estimate when multiple files need time estimates

---

### Iteration 54 - US-054: Create Dockerfile for deployment
**Status:** ✅ SUCCESS
**What was done:**
- Created `Dockerfile` with multi-stage build (deps → builder → runner)
- Stage 1 (deps): Uses node:20-alpine, installs dependencies with npm ci
- Stage 2 (builder): Copies deps, builds Next.js app with NODE_ENV=production
- Stage 3 (runner): Production image with node:20-alpine, non-root user (nextjs)
- Set NODE_ENV=production and NEXT_TELEMETRY_DISABLED=1
- Expose port 3000 with HOSTNAME="0.0.0.0"
- CMD ["node", "server.js"] for standalone output
- Updated next.config.ts with output: 'standalone'
- Verified typecheck passes with `npm run build`

**Learnings:**
- Next.js standalone output creates a minimal server.js that can run without node_modules
- Use libc6-compat on Alpine for better compatibility with native modules
- Create non-root user (nextjs:nodejs) for security best practices
- Copy .next/standalone and .next/static separately for proper build output

---

### Iteration 55 - US-055: Create docker-compose.yml
**Status:** ✅ SUCCESS
**What was done:**
- Created `docker-compose.yml` with 'app' service building from Dockerfile
- Port mapping 3000:3000 for container access
- Environment variables: NODE_ENV=production, NEXT_TELEMETRY_DISABLED=1
- Created `docker-compose.dev.yml` for development override with volume mounting (.:/app)
- Dev override excludes node_modules and .next from bind mount
- Added healthcheck for container monitoring (wget to localhost:3000)
- Verified typecheck passes with `npm run build`

**Learnings:**
- Use separate docker-compose.dev.yml for development overrides to keep production config clean
- Exclude node_modules and .next from bind mounts to prevent conflicts with host filesystem
- WATCHPACK_POLLING=true needed for file watching in Docker containers

---

### Iteration 56 - US-056: Add meta tags and SEO
**Status:** ✅ SUCCESS
**What was done:**
- Updated `src/app/[locale]/layout.tsx` metadata export with full SEO configuration
- Title: "aepoconvert — Free Online File Converter"
- Description: "Convert images, audio, and documents for free. 100% private — all processing happens in your browser."
- Added Open Graph tags: title, description, type, url, siteName, locale
- Added Twitter card: summary_large_image, title, description, creator
- Added keywords, authors, creator, robots configuration
- Favicon.ico already present at src/app/favicon.ico
- Verified typecheck passes with `npm run build`

**Learnings:**
- Next.js Metadata API in App Router uses typed export for meta tags
- metadataBase URL is used to resolve relative URLs in Open Graph images
- icons.icon points to favicon.ico in the app directory

---

### Iteration 58 - US-058: Create error page
**Status:** ✅ SUCCESS
**What was done:**
- Verified `src/app/error.tsx` already exists as a client component with "use client" directive
- Component displays "Something went wrong" message with "Oops!" heading
- Has retry button with RotateCcw icon that calls `reset()` function
- Has link to home page with Home icon using Next.js Link component
- Matches app design style: gradient button, lucide icons, destructive color theme for error
- Shows error digest ID for debugging when available
- Verified typecheck passes with `npm run build`
- Verified app runs correctly in browser (error boundary only shows on actual errors)

**Learnings:**
- Next.js error.tsx is an error boundary component that only renders when errors occur
- Cannot directly navigate to error page - it intercepts runtime errors
- Error component receives { error, reset } props from Next.js error boundary

---

### Iteration 59 - US-059: Add PWA manifest
**Status:** ✅ SUCCESS
**What was done:**
- Created `public/manifest.json` with PWA configuration
- Set name: "aepoconvert" and short_name: "aepoconvert"
- Created 192x192 and 512x512 PNG icons in `public/icons/` directory
- Set theme_color: "#8b5cf6" (purple matching app theme) and background_color: "#09090b" (zinc dark)
- Set display: "standalone" for native-like experience
- Added manifest link to layout.tsx metadata export
- Added apple-touch-icon reference for iOS support
- Verified typecheck passes with `npm run build`

**Learnings:**
- Next.js Metadata API supports `manifest` field for PWA manifest linking
- Icons with "purpose": "any maskable" work for both regular and adaptive icon contexts
- PNG icons can be programmatically generated with Node.js zlib for simple solid-color placeholders

---

### Iteration 60 - US-060 (Criterion 1): All buttons have aria-label when icon-only
**Status:** ✅ SUCCESS
**What was done:**
- Audited all components for icon-only buttons (buttons with only icons, no visible text)
- Found 2 icon-only buttons in the codebase:
  1. Theme toggle button in Header.tsx (line 62-76) - already has dynamic aria-label "Switch to light/dark mode"
  2. Remove file button in FileCard.tsx (line 112-120) - already has aria-label "Remove {filename}"
- All other buttons have visible text content so don't require aria-label
- GitHub link in Footer.tsx has aria-label="View source on GitHub"
- DropZone div with role="button" has aria-label="Drop files here or click to browse"
- Verified typecheck passes with `npm run build`

**Learnings:**
- Icon-only buttons were already properly labeled during component implementation
- Use `size="icon"` variant in shadcn Button to identify icon-only buttons
- Good practice to include aria-label during initial component development, not as an afterthought

---

### Iteration 61 - US-060 (Criterion 2): Focus states visible on all interactive elements
**Status:** ✅ SUCCESS
**What was done:**
- Updated `--ring` CSS variable in globals.css to use a more vibrant purple color (oklch 0.55 0.15 270 for light, 0.7 0.2 270 for dark)
- Added global focus styles in @layer base for `a:focus-visible` and `[tabindex]:not([tabindex="-1"]):focus-visible`
- Updated PrivacyBadge.tsx: changed div to button element with proper focus-visible styles (green ring to match badge color)
- Updated Footer.tsx GitHub link: added explicit focus-visible ring styles with padding for better visual
- Verified all interactive elements can be tabbed through: theme toggle → privacy badge → dropzone → settings button → quality buttons → GitHub link
- Verified typecheck passes with `npm run build`

**Learnings:**
- The default `--ring` color in shadcn/ui is very muted (low chroma); increasing chroma makes focus states more visible
- Changing tooltip trigger from div to button makes it keyboard-accessible automatically
- Global focus styles in @layer base provide fallback for any elements missing explicit focus styling
- Test focus navigation by pressing Tab repeatedly through the UI

---

### Iteration 62 - US-060 (Criterion 3): Color contrast meets WCAG AA (4.5:1 for text)
**Status:** ✅ SUCCESS
**What was done:**
- Darkened `--muted-foreground` from oklch(0.552) to oklch(0.45) in light mode for 4.5:1+ contrast ratio
- Removed opacity modifiers (`/70`, `/60`) from muted-foreground text classes that reduced contrast below threshold
- Updated PrivacyBadge green text from `text-green-600` to `text-green-700` for better contrast on white
- Files updated: globals.css, DropZone.tsx, FileList.tsx, error.tsx, PrivacyBadge.tsx
- Verified typecheck passes with `npm run build`
- Verified visually in browser - both light and dark modes have readable muted text

**Learnings:**
- OKLCH lightness of 0.552 (~55%) on white background is borderline 4.48:1 - needs 0.45 (~45%) for safe 4.5:1
- Opacity modifiers like `/70` on already-muted colors can push contrast below acceptable thresholds
- Tailwind green-600 (#16a34a) is ~4.55:1, green-700 (#15803d) is ~5.9:1 - use 700 for safety margin
- Dark mode muted-foreground at 0.705 lightness on 0.141 background has excellent contrast (no change needed)

---

### Iteration 63 - US-060 (Criterion 4): Screen reader announces status changes (aria-live regions)
**Status:** ✅ SUCCESS
**What was done:**
- Created `src/components/status/StatusAnnouncer.tsx` with centralized aria-live announcements
- Added assertive aria-live region for critical updates (conversion start/complete/error)
- Added polite aria-live region for less urgent updates (file add/remove)
- Updated `ConversionProgress.tsx` with role="status" and aria-live on each status state
- Added role="progressbar" with aria-valuenow/min/max to progress bar for screen reader progress tracking
- Updated `ConverterStatus.tsx` with aria-live announcements when converters become ready or fail
- Added StatusAnnouncer to layout.tsx alongside other global components
- Verified 4 aria-live regions render in the DOM (2 from StatusAnnouncer, 1 from ConverterStatus, 1 from sonner)
- Verified typecheck passes with `npm run build`
- Verified changes work in browser with Playwright

**Learnings:**
- Use assertive aria-live for critical changes users need to know immediately (errors, completion)
- Use polite aria-live for non-urgent updates (file additions) to avoid interrupting user flow
- Clear announcements after ~1 second to prevent stale messages from being re-announced
- role="progressbar" with aria-valuenow provides screen reader users with progress information

---

### Iteration 64 - US-060 (Criterion 5): Keyboard navigation works: Tab through all controls
**Status:** ✅ SUCCESS
**What was done:**
- Verified all interactive elements are already keyboard-accessible (buttons, links, form controls)
- Fixed collapsed SettingsPanel content being focusable even when hidden
- Added `inert` attribute to collapsed content to exclude hidden controls from tab order
- Tab order now properly follows visual layout:
  1. Theme toggle button (header)
  2. Privacy badge (main)
  3. Drop zone (main)
  4. Settings toggle button (main)
  5. When expanded: Simple/Advanced tabs → Quality buttons
  6. GitHub link (footer)
- Verified typecheck passes with `npm run build`
- Verified keyboard navigation works correctly in browser with Playwright

**Learnings:**
- `aria-hidden` only hides content from screen readers but doesn't prevent keyboard focus
- Use `inert` attribute to remove elements from both accessibility tree and tab order
- Spread syntax `{...(!isOpen && { inert: true })}` cleanly applies conditional boolean attributes
- React doesn't emit warning for `inert={true}` unlike `inert=""`
